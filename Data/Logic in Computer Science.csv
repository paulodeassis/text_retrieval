Proceedings of the First Workshop on Coalgebra, Horn Clause Logic Programming and Types;Ekaterina Komendantskaya (Heriot-Watt University), John Power (University of Bath);The Workshop on Coalgebra, Horn Clause Logic Programming and Types was held on the 28-29 November 2016 in Edinburgh. The workshop marked the end of the EPSRC Grant Coalgebraic Logic Programming for Type Inference, by E. Komendantskaya, Heriot-Watt University and J. Power, University of Bath, UK.;https://arxiv.org/abs/1709.04199;;;
On the decidability of the existence of polyhedral invariants in transition systems;David Monniaux (VERIMAG - IMAG);"Automated program verification often proceeds by exhibiting inductive invariants entailing the desired properties.For numerical properties, a classical class of invariants is convex polyhedra: solution sets of system of linear (in)equalities.Forty years of research on convex polyhedral invariants have focused, on the one hand, on identifying ""easier"" subclasses, on the other hand on heuristics for finding general convex polyhedra.These heuristics are however not guaranteed to find polyhedral inductive invariants when they exist.To our best knowledge, the existence of polyhedral inductive invariants has never been proved to be undecidable.In this article, we show that the existence of convex polyhedral invariants is undecidable, even if there is only one control state in addition to the ""bad"" one.The question is still open if one is not allowed any nonlinear constraint.";https://arxiv.org/abs/1709.04382;;;
On the Generation of Initial Contexts for Effective Deadlock Detection;Elvira Albert, Miguel Gómez-Zamalloa, Miguel Isabel;It has been recently proposed that testing based on symbolic execution can be used in conjunction with static deadlock analysis to define a deadlock detection framework that: (i) can show deadlock presence, in that case a concrete test-case and trace are obtained, and (ii) can also prove deadlock freedom. Such symbolic execution starts from an initial distributed context, i.e., a set of locations and their initial tasks. Considering all possibilities results in a combinatorial explosion on the different distributed contexts that must be considered. This paper proposes a technique to effectively generate initial contexts that can lead to deadlock, using the possible conflicting task interactions identified by static analysis, discarding other distributed contexts that cannot lead to deadlock. The proposed technique has been integrated in the above-mentioned deadlock detection framework hence enabling it to analyze systems without the need of any user supplied initial context.;https://arxiv.org/abs/1709.04255;;;
On the Accuracy of Formal Verification of Selective Defenses for TDoS Attacks;Marcilio O. O. Lemos, Yuri Gil Dantas, Iguatemi E. Fonseca, Vivek Nigam;Telephony Denial of Service (TDoS) attacks target telephony services, such as Voice over IP (VoIP), not allowing legitimate users to make calls. There are few defenses that attempt to mitigate TDoS attacks, most of them using IP filtering, with limited applicability. In our previous work, we proposed to use selective strategies for mitigating HTTP Application-Layer DDoS Attacks demonstrating their effectiveness in mitigating different types of attacks. Developing such types of defenses is challenging as there are many design options, eg, which dropping functions and selection algorithms to use. Our first contribution is to demonstrate both experimentally and by using formal verification that selective strategies are suitable for mitigating TDoS attacks. We used our formal model to help decide which selective strategies to use with much less effort than carrying out experiments. Our second contribution is a detailed comparison of the results obtained from our formal models and the results obtained by carrying out experiments. We demonstrate that formal methods is a powerful tool for specifying defenses for mitigating Distributed Denial of Service attacks allowing to increase our confidence on the proposed defense before actual implementation.;https://arxiv.org/abs/1709.04162;;;
FO model checking of geometric graphs;Petr Hlin?ný, Filip Pokrývka, Bodhayan Roy;Over the past two decades the main focus of research into first-order (FO) model checking algorithms has been on sparse relational structures - culminating in the FPT algorithm by Grohe, Kreutzer and Siebertz for FO model checking of nowhere dense classes of graphs. On contrary to that, except the case of locally bounded clique-width only little is currently known about FO model checking of dense classes of graphs or other structures. We study the FO model checking problem for dense graph classes definable by geometric means (intersection and visibility graphs). We obtain new nontrivial FPT results, e.g., for restricted subclasses of circular-arc, circle, box, disk, and polygon-visibility graphs. These results use the FPT algorithm by Gajarsk\'y et al. for FO model checking of posets of bounded width. We also complement the tractability results by related hardness reductions.;https://arxiv.org/abs/1709.03701;;;
Finite-state Strategies in Delay Games;Martin Zimmermann (Saarland University);What is a finite-state strategy in a delay game? We answer this surprisingly non-trivial question and present a very general framework for computing such strategies: they exist for all winning conditions that are recognized by automata with acceptance conditions that satisfy a certain aggregation property. Our framework also yields upper bounds on the complexity of determining the winner of such delay games and upper bounds on the necessary lookahead to win the game. In particular, we cover all previous results of that kind as special cases of our uniform approach.;https://arxiv.org/abs/1709.03539;;;
On A New Convergence Class in Sup-sober Spaces;Hadrian Andradi, Weng Kin Ho;Recently, J. D. Lawson encouraged the domain theory community to consider the scientific program of developing domain theory in the wider context of T_0;;;;
Monadic Second-Order Logic with Arbitrary Monadic Predicates;Nathanaël Fijalkow, Charles Paperman;We study Monadic Second-Order Logic (MSO) over finite words, extended with (non-uniform arbitrary) monadic predicates. We show that it defines a class of languages that has algebraic, automata-theoretic and machine-independent characterizations. We consider the regularity question: given a language in this class, when is it regular? To answer this, we show a substitution property and the existence of a syntactical predicate.;;;;
Defining Recursive Predicates in Graph Orders;Ramanathan S. Thinniyam;We study the first order theory of structures over graphs i.e. structures of the form (;;;;
Simulating Linear Logic in 1-Only Linear Logic;Max Kanovich;Linear Logic was introduced by Girard as a resource-sensitive refinement of classical logic. It turned out that full propositional Linear Logic is undecidable (Lincoln, Mitchell, Scedrov, and Shankar) and, hence, it is more expressive than (modalized) classical or intuitionistic logic. In this paper we focus on the study of the simplest fragments of Linear Logic, such as the one-literal and constant-only fragments (the latter contains no literals at all). Here we demonstrate that all these extremely simple fragments of Linear Logic (one-literal,;;;;
Design Methods for Polymorphic Combinational Logic Circuits based on the Bi_Decomposition Approach;Zhifang Li, Wenjian Luo, Lihua Yue, Xufa Wang;Polymorphic circuits are a special kind of digital logic components, which possess multiple build-in functions. In different environments, a polymorphic circuit would perform different functions. Evolutionary Algorithms, Binary Decision Diagrams (BDD) and the multiplex method have been adopted to design polymorphic circuits. However, the evolutionary methods face the scalable problem. The BDD method consumes too much gate resource. The polymorphic circuit built by the multiplex method rarely contains polymorphic gates. In this paper, based on the traditional Bi_Decomposition circuit design approach, two methods, i.e. the Poly_Bi_Decomposition method and the Transformation&Bi_Decomposition method, are proposed for designing polymorphic circuits. The Poly_Bi_Decomposition method can design relatively large and gate-efficient polymorphic circuits with a higher percentage of polymorphic gates. The Transformation&Bi_Decomposition method can use the traditional circuit design approaches and tools, e.g. Bi_Decomposition, to design polymorphic circuits directly. The experimental results show the good performance of the proposed methods.;https://arxiv.org/abs/1709.03067;;;
A Simplification Method of Polymorphic Boolean Functions;Wenjian Luo, Zhifang Li;Polymorphic circuits are a special kind of circuits which possess multiple build-in functions, and these functions are activated by environment parameters, like temperature, light and VDD. The behavior of a polymorphic circuit can be described by a polymorphic Boolean function. For the first time, this brief presents a simplification method of the polymorphic Boolean function.;https://arxiv.org/abs/1709.03066;;;
A Straightforward Method to Judge the Completeness of a Polymorphic Gate Set;Zhifang Li, Wenjian Luo, Lihua Yue, Xufa Wang;Polymorphic circuits are a special kind of circuits which possess some different build-in functions and these functions are activated by environment parameters, like light and VDD. Some theories have been proposed to guide the design of polymorphic circuits, including the definition of complete polymorphic gate sets and algorithms to judge the completeness of a polymorphic gate set.;;;;
Towards Proving the Adversarial Robustness of Deep Neural Networks;Guy Katz (Stanford University), Clark Barrett (Stanford University), David L. Dill (Stanford University), Kyle Julian (Stanford University), Mykel J. Kochenderfer (Stanford University);Autonomous vehicles are highly complex systems, required to function reliably in a wide variety of situations. Manually crafting software controllers for these vehicles is difficult, but there has been some success in using deep neural networks generated using machine-learning. However, deep neural networks are opaque to human engineers, rendering their correctness very difficult to prove manually; and existing automated techniques, which were not designed to operate on neural networks, fail to scale to large systems. This paper focuses on proving the adversarial robustness of deep neural networks, i.e. proving that small perturbations to a correctly-classified input to the network cannot cause it to be misclassified. We describe some of our recent and ongoing work on verifying the adversarial robustness of networks, and discuss some of the open questions we have encountered and how they might be addressed.;https://arxiv.org/abs/1709.02802;;
Imperfect Knowledge in Autonomous Urban Traffic Manoeuvres;Maike Schwammberger (University of Oldenburg);Urban Multi-lane Spatial Logic (UMLSL) was introduced in [13] for proving safety (collision freedom) in autonomous urban traffic manoeuvres with perfect knowledge. We now consider a concept of imperfect knowledge, where cars have less information about other cars. To this end, we introduce the concept of a multi-view and propose crossing controllers using broadcast communication with data constraints for turning manoeuvres at intersections.;https://arxiv.org/abs/1709.02559;;;
Monitoring of Traffic Manoeuvres with Imprecise Information;Heinrich Ody;In monitoring, we algorithmically check if a single behavior satisfies a property. Here, we consider monitoring for Multi-Lane Spatial Logic (MLSL). The behavior is given as a finite transition sequence of MLSL and the property is that a spatial MLSL formula should hold at every point in time within the sequence. In our procedure we transform the transition sequence and the formula to the first-order theory of real-closed fields, which is decidable, such that the resulting formula is valid iff the MLSL formula holds throughout the transition sequence. We then assume that temporal data may have an error of up to;;;;
A Rational Agent Controlling an Autonomous Vehicle: Implementation and Formal Verification;Lucas E. R. Fernandes (1), Vinicius Custodio (1), Gleifer V. Alves (1), Michael Fisher (2) ((1) UTFPR, Ponta Grossa, Parana, Brazil, (2) University of Liverpool, Liverpool, United Kingdom);The development and deployment of Autonomous Vehicles (AVs) on our roads is not only realistic in the near future but can also bring significant benefits. In particular, it can potentially solve several problems relating to vehicles and traffic, for instance: (i) possible reduction of traffic congestion, with the consequence of improved fuel economy and reduced driver inactivity; (ii) possible reduction in the number of accidents, assuming that an AV can minimise the human errors that often cause traffic accidents; and (iii) increased ease of parking, especially when one considers the potential for shared AVs. In order to deploy an AV there are significant steps that must be completed in terms of hardware and software. As expected, software components play a key role in the complex AV system and so, at least for safety, we should assess the correctness of these components.;;
Sequential Composition in the Presence of Intermediate Termination (Extended Abstract);Jos Baeten (CWI and University of Amsterdam), Bas Luttik (Eindhoven University of Technology), Fei Yang (Eindhoven University of Technology);The standard operational semantics of the sequential composition operator gives rise to unbounded branching and forgetfulness when transparent process expressions are put in sequence. Due to transparency, the correspondence between context-free and pushdown processes fails modulo bisimilarity, and it is not clear how to specify an always terminating half counter. We propose a revised operational semantics for the sequential composition operator in the context of intermediate termination. With the revised operational semantics, we eliminate transparency, allowing us to establish a close correspondence between context-free processes and pushdown processes. Moreover, we prove the reactive Turing powerfulness of TCP with iteration and nesting with the revised operational semantics for sequential composition.;https://arxiv.org/abs/1709.02440;;;
The Shape of a Benedictine Monastery: The SaintGall Ontology;Claudia Cantale, Domenico Cantone, Marianna Nicolosi-Asmundo, Daniele Francesco Santamaria;We present an OWL 2 ontology representing the Saint Gall plan, one of the most ancient documents arrived intact to us, that describes the ideal model of a Benedictine monastic complex, and that inspired the design of many European monasteries.;https://arxiv.org/abs/1709.02618;;;
Causality-Aided Falsification;Takumi Akazaki (1), Yoshihiro Kumazawa (1), Ichiro Hasuo (2) ((1) University of Tokyo, (2) National Institute of Informatics);Falsification is drawing attention in quality assurance of heterogeneous systems whose complexities are beyond most verification techniques' scalability. In this paper we introduce the idea of causality aid in falsification: by providing a falsification solver -- that relies on stochastic optimization of a certain cost function -- with suitable causal information expressed by a Bayesian network, search for a falsifying input value can be efficient. Our experiment results show the idea's viability.;https://arxiv.org/abs/1709.02555;;;
On the Complexity of ATL and ATL* Module Checking;Laura Bozzelli, Aniello Murano;Module checking has been introduced in late 1990s to verify open systems, i.e., systems whose behavior depends on the continuous interaction with the environment. Classically, module checking has been investigated with respect to specifications given as CTL and CTL* formulas. Recently, it has been shown that CTL (resp., CTL*) module checking offers a distinctly different perspective from the better-known problem of ATL (resp., ATL*) model checking. In particular, ATL (resp., ATL*) module checking strictly enhances the expressiveness of both CTL (resp., CTL*) module checking and ATL (resp. ATL*) model checking. In this paper, we provide asymptotically optimal bounds on the computational cost of module checking against ATL and ATL*, whose upper bounds are based on an automata-theoretic approach. We show that module-checking for ATL is EXPTIME-complete, which is the same complexity of module checking against CTL. On the other hand, ATL* module checking turns out to be 3EXPTIME-complete, hence exponentially harder than CTL* module checking.;https://arxiv.org/abs/1709.02107;;;
A Backward-traversal-based Approach for Symbolic Model Checking of Uniform Strategies for Constrained Reachability;Simon Busard (UCLouvain, Belgium), Charles Pecheur (UCLouvain, Belgium);Since the introduction of Alternating-time Temporal Logic (ATL), many logics have been proposed to reason about different strategic capabilities of the agents of a system. In particular, some logics have been designed to reason about the uniform memoryless strategies of such agents. These strategies are the ones the agents can effectively play by only looking at what they observe from the current state. ATL_ir can be seen as the core logic to reason about such uniform strategies. Nevertheless, its model-checking problem is difficult (it requires a polynomial number of calls to an NP oracle), and practical algorithms to solve it appeared only recently.;;;;
Model Checking Social Network Models;Raúl Pardo (Chalmers | University of Gothenburg), Gerardo Schneider (Chalmers | University of Gothenburg);"A social network service is a platform to build social relations among people sharing similar interests and activities. The underlying structure of a social networks service is the social graph, where nodes represent users and the arcs represent the users' social links and other kind of connections. One important concern in social networks is privacy: what others are (not) allowed to know about us. The ""logic of knowledge"" (epistemic logic) is thus a good formalism to define, and reason about, privacy policies. In this paper we consider the problem of verifying knowledge properties over social network models (SNMs), that is social graphs enriched with knowledge bases containing the information that the users know. More concretely, our contributions are: i) We prove that the model checking problem for epistemic properties over SNMs is decidable"; ii) We prove that a number of properties of knowledge that are sound w.r.t. Kripke models are also sound w.r.t. SNMs; iii) We give a satisfaction-preserving encoding of SNMs into canonical Kripke models, and we also characterise which Kripke models may be translated into SNMs; iv) We show that, for SNMs, the model checking problem is cheaper than the one based on standard Kripke models. Finally, we have developed a proof-of-concept implementation of the model-checking algorithm for SNMs.;https://arxiv.org/abs/1709.02105
T-regular Expressions and Counter-Check Automata;"Dario Della Monica (Universidad Complutense de Madrid, Spain, and Università ""Federico II"" di Napoli, Italy), Angelo Montanari (Università di Udine, Italy), Pietro Sala (Università di Verona)";In the last years, various extensions of {\omega}-regular languages have been proposed in the literature, including {\omega}B-regular ({\omega}-regular languages extended with boundedness), {\omega}S-regular ({\omega}-regular languages extended with strict unboundedness), and {\omega}BS-regular languages (the combination of {\omega}B- and {\omega}S-regular ones). While the first two classes satisfy a generalized closure property, namely, the complement of an {\omega}B-regular (resp., {\omega}S-regular) language is an {\omega}S-regular (resp., {\omega}B-regular) one, the last class is not closed under complementation. The existence of non-{\omega}BS-regular languages that are the complements of some {\omega}BS-regular ones and express fairly natural properties of reactive systems motivates the search for other well-behaved classes of extended {\omega}-regular languages. In this paper, we introduce the class of {\omega}T-regular languages, that includes meaningful languages which are not {\omega}BS-regular. We first define it in terms of {\omega}T-regular expressions. Then, we introduce a new class of automata (counter-check automata) and we prove that (i) their emptiness problem is decidable in PTIME and (ii) they are expressive enough to capture {\omega}T-regular languages (whether or not {\omega}T-regular languages are expressively complete with respect to counter-check automata is still an open problem). Finally, we provide an encoding of {\omega}T-regular expressions into S1S+U.;https://arxiv.org/abs/1709.02104;;;
Linear-time Temporal Logic with Event Freezing Functions;Stefano Tonetta (FBK-irst);Formal properties represent a cornerstone of the system-correctness proofs based on formal verification techniques such as model checking. Formalizing requirements into temporal properties may be very complex and error prone, due not only to the ambiguity of the textual requirements but also to the complexity of the formal language. Finding a property specification language that balances simplicity, expressiveness, and tool support remains an open problem in many real-world contexts.;;;;
